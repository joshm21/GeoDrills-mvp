<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polyform Quiz Renderer</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        :root {
            --primary: #007bff;
            --success: #28a745;
            --error: #dc3545;
            --bg: #f4f4f9;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, sans-serif;
            background-color: var(--bg);
            margin: 0;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #app {
            width: 100%;
            max-width: 650px;
            height: 90vh;
            background: white;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .content-section {
            flex-grow: 1;
            overflow-y: auto;
            padding: 0rem 2rem;
            display: flex;
            flex-direction: column;
        }

        .prompt-area {
            height: 33%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            flex-shrink: 0;
        }

        .response-area {
            margin-top: auto;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding-bottom: 1rem;
        }

        .footer-section {
            padding: 1rem 0;
            border-top: 1px solid #eee;
            text-align: right;
            background: #fdfdfd;
        }

        .media-placeholder {
            height: 80px;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .question-img {
            max-height: 100%;
            max-width: 100%;
            border-radius: 8px;
            object-fit: contain;
        }

        .response-grid {
            display: grid;
            gap: 1rem;
        }

        .card {
            border: 2px solid #eee;
            height: 15vh;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 12px;
            cursor: pointer;
            background: #fff;
        }

        .card.correct {
            border-color: var(--success);
            background: #f0fff4;
        }

        .card.incorrect {
            border-color: var(--error);
            background: #fff5f5;
        }

        .card-img-wrapper {
            flex: 1;
            width: 100%;
            display: flex;
            justify-content: center;
            overflow: hidden;
        }

        .card-img-wrapper img {
            height: 100%;
            width: 100%;
            object-fit: contain;
        }

        .input-stack {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        input[type="text"] {
            width: 100%;
            padding: 14px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            font-size: 0.95rem;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .btn-outline {
            background: #fff;
            color: #444;
            border: 2px solid #ddd;
        }

        .btn-recording {
            background: var(--error);
            color: white;
            animation: pulse 1.5s infinite;
        }

        .feedback-area {
            min-height: 30px;
            margin-bottom: 1rem;
            text-align: center;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.4);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(220, 53, 69, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(220, 53, 69, 0);
            }
        }
    </style>
</head>

<body>
    <div id="app">
        <div v-if="currentCard && currentCard.prompt" style="display:contents;">
            <div class="content-section">
                <div class="prompt-area">
                    <div v-if="currentCard.prompt.image || currentCard.prompt.audio" class="media-placeholder">
                        <img v-if="currentCard.prompt.image" :src="currentCard.prompt.image" class="question-img">
                        <audio v-else-if="currentCard.prompt.audio" ref="audioPromptRef" controls
                            :src="currentCard.prompt.audio" style="width:100%;"></audio>
                    </div>
                    <h2 style="font-size: 1.2rem; margin: 0; color: #2d3436; text-align: center;">
                        {{ currentCard.prompt.text }}
                    </h2>
                </div>

                <div class="response-area">
                    <div class="feedback-area">
                        <span v-if="feedback.msg"
                            :style="{ color: feedback.type === 'success' ? 'var(--success)' : 'var(--error)' }">
                            {{ feedback.msg }}
                        </span>
                    </div>

                    <div v-if="currentCard.response?.choices" class="response-grid"
                        style="grid-template-columns: repeat(2, 1fr);">
                        <div v-for="(choice, i) in currentCard.response.choices" :key="i" class="card"
                            :class="{ correct: selectedIndex === i && choice.isCorrect, incorrect: selectedIndex === i && !choice.isCorrect }"
                            @click="selectCard(i, choice.isCorrect)">
                            <div class="card-img-wrapper" v-if="choice.image"><img :src="choice.image"></div>
                            <div v-if="choice.text" style="margin-top:10px;"><b>{{ choice.text }}</b></div>
                        </div>
                    </div>

                    <div v-if="currentCard.response?.textAnswer !== undefined && !currentCard.response?.choices"
                        class="input-stack">
                        <input type="text" v-model="textInput" placeholder="Type answer..." @keyup.enter="checkText">
                        <button class="btn btn-primary" @click="checkText">Check</button>
                    </div>

                    <div v-if="currentCard.response?.audioAnswer" class="input-stack">
                        <div style="display:flex; gap:8px;">
                            <button v-if="!recordedUrl || isRecording" class="btn"
                                :class="isRecording ? 'btn-recording' : 'btn-outline'" @click="handleRecordClick"
                                style="flex:1">
                                {{ isRecording ? 'Stop' : 'üé§ Record' }}
                            </button>
                            <button v-else class="btn btn-outline" @click="toggleUserPlayback" style="flex:1">
                                {{ userAudioPlaying ? '‚è∏ Pause' : '‚ñ∂Ô∏è Replay' }}
                            </button>
                        </div>
                        <button class="btn btn-primary" :disabled="!recordedUrl || isRecording"
                            @click="toggleCorrectPlayback">
                            {{ correctAudioPlaying ? '‚è∏ Pause' : 'üîä Check' }}
                        </button>
                        <audio ref="userAudioRef" :src="recordedUrl" hidden></audio>
                        <audio ref="correctAudioRef" :src="currentCard.response.audioAnswer" hidden></audio>
                    </div>
                </div>

                <div class="footer-section">
                    <button class="btn btn-primary" @click="advanceToNext" :disabled="!nextCard">
                        {{ nextCard ? '‚è≠Ô∏è Next' : 'Loading...' }}
                    </button>
                </div>
            </div>
        </div>

        <div v-else class="content-section" style="text-align:center; justify-content:center;">
            <p v-if="!errorMessage">Loading first question...</p>
            <p v-else style="color: var(--error)">{{ errorMessage }}</p>
        </div>
    </div>

    <script>
        const {createApp, ref, nextTick} = Vue;
        createApp({
            setup() {
                const currentCard = ref(null);
                const nextCard = ref(null);
                const errorMessage = ref('');
                const drillId = new URLSearchParams(window.location.search).get('drill');

                // ... keep your other refs (selectedIndex, feedback, etc.) ...
                const selectedIndex = ref(null);
                const textInput = ref('');
                const feedback = ref({msg: '', type: ''});
                const recordedUrl = ref(null);
                const isRecording = ref(false);
                const userAudioPlaying = ref(false);
                const correctAudioPlaying = ref(false);
                const userAudioRef = ref(null);
                const correctAudioRef = ref(null);
                const audioPromptRef = ref(null);
                let mediaRecorder = null;
                let chunks = [];

                const API_BASE = 'https://script.google.com/macros/s/AKfycby8ysnyr83c-vYmQ9QZtz6z1Til2BwlICE2O0nL8KrVjEYIwO3zZ4P0H2hHELeW6uSbQQ/exec';

                const fetchQuestion = async () => {
                    if (!drillId) return null;
                    try {
                        const response = await fetch(`${API_BASE}?drill=${drillId}`);
                        const json = await response.json();

                        // IMPORTANT: Unpack the .data from your new API structure
                        if (json.status === "ok") {
                            return json.data;
                        } else {
                            console.error("API Error:", json.data);
                            return null;
                        }
                    } catch (e) {
                        console.error("Fetch error:", e);
                        return null;
                    }
                };

                const loadInitialData = async () => {
                    if (!drillId) {
                        errorMessage.value = "No Drill ID provided in URL (?drill=xxx)";
                        return;
                    }

                    const [first, second] = await Promise.all([fetchQuestion(), fetchQuestion()]);

                    if (first) {
                        currentCard.value = first;
                        nextCard.value = second;
                        handleAudioAutoplay();
                    } else {
                        errorMessage.value = "Failed to load data from API.";
                    }
                };

                const advanceToNext = async () => {
                    if (!nextCard.value) return;

                    resetUI();
                    currentCard.value = nextCard.value;
                    nextCard.value = null;

                    fetchQuestion().then(data => {
                        nextCard.value = data;
                    });

                    await nextTick();
                    handleAudioAutoplay();
                };

                // ... (Keep handleRecordClick, toggleUserPlayback, etc. exactly as they were) ...
                const handleAudioAutoplay = async () => {
                    if (currentCard.value?.prompt?.audio) {
                        await nextTick();
                        if (audioPromptRef.value) {
                            audioPromptRef.value.load();
                            audioPromptRef.value.play().catch(() => console.log("Autoplay blocked"));
                        }
                    }
                };

                const resetUI = () => {
                    selectedIndex.value = null;
                    textInput.value = '';
                    feedback.value = {msg: '', type: ''};
                    recordedUrl.value = null;
                };

                const selectCard = (idx, isCorrect) => {
                    selectedIndex.value = idx;
                    feedback.value = isCorrect ? {msg: '‚úÖ Correct!', type: 'success'} : {msg: '‚ùå Incorrect.', type: 'error'};
                };

                const checkText = () => {
                    const answer = currentCard.value.response.textAnswer || '';
                    const isCorrect = textInput.value.toLowerCase().trim() === answer.toLowerCase().trim();
                    feedback.value = isCorrect ? {msg: '‚úÖ Correct!', type: 'success'} : {msg: `‚ùå Incorrect.`, type: 'error'};
                };

                const handleRecordClick = async () => {
                    if (isRecording.value) {
                        mediaRecorder.stop();
                        isRecording.value = false;
                    } else {
                        try {
                            const stream = await navigator.mediaDevices.getUserMedia({audio: true});
                            mediaRecorder = new MediaRecorder(stream);
                            chunks = [];
                            mediaRecorder.ondataavailable = e => chunks.push(e.data);
                            mediaRecorder.onstop = async () => {
                                const blob = new Blob(chunks, {type: 'audio/webm'});
                                recordedUrl.value = URL.createObjectURL(blob);
                                await nextTick();
                                userAudioRef.value.load();
                                stream.getTracks().forEach(t => t.stop());
                            };
                            mediaRecorder.start();
                            isRecording.value = true;
                        } catch (err) {
                            feedback.value = {msg: "Microphone access denied.", type: "error"};
                        }
                    }
                };

                const toggleUserPlayback = () => {
                    const a = userAudioRef.value;
                    userAudioPlaying.value ? a.pause() : a.play();
                    userAudioPlaying.value = !userAudioPlaying.value;
                    a.onended = () => userAudioPlaying.value = false;
                };

                const toggleCorrectPlayback = () => {
                    const a = correctAudioRef.value;
                    correctAudioPlaying.value ? a.pause() : a.play();
                    correctAudioPlaying.value = !correctAudioPlaying.value;
                    a.onended = () => correctAudioPlaying.value = false;
                };

                loadInitialData();

                return {
                    currentCard, nextCard, errorMessage, selectedIndex, textInput, feedback,
                    recordedUrl, isRecording, userAudioPlaying, correctAudioPlaying,
                    userAudioRef, correctAudioRef, audioPromptRef,
                    advanceToNext, selectCard, checkText, handleRecordClick,
                    toggleUserPlayback, toggleCorrectPlayback
                };
            }
        }).mount('#app');
    </script>
</body>


</html>

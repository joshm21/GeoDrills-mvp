<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polyform Quiz Renderer</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        :root {
            --primary: #007bff;
            --success: #28a745;
            --error: #dc3545;
            --bg: #f4f4f9;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, sans-serif;
            background-color: var(--bg);
            margin: 0;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #app {
            width: 100%;
            max-width: 650px;
            height: 90vh;
            background: white;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .content-section {
            flex-grow: 1;
            overflow-y: auto;
            padding: 0rem 2rem;
            display: flex;
            flex-direction: column;
        }

        .prompt-area {
            height: 33%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            flex-shrink: 0;
        }

        .response-area {
            margin-top: auto;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding-bottom: 1rem;
        }

        .footer-section {
            padding: 1rem 0;
            border-top: 1px solid #eee;
            text-align: right;
            background: #fdfdfd;
        }

        .media-placeholder {
            height: 80px;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .question-img {
            max-height: 100%;
            max-width: 100%;
            border-radius: 8px;
            object-fit: contain;
        }

        .response-grid {
            display: grid;
            gap: 1rem;
        }

        .card {
            position: relative;
            border: 2px solid #eee;
            height: 15vh;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 12px;
            cursor: pointer;
            background: #fff;
            transition: transform 0.1s;
        }

        .card:active {
            transform: scale(0.98);
        }

        .card.correct {
            border-color: var(--success);
            background: #f0fff4;
        }

        .card.incorrect {
            border-color: var(--error);
            background: #fff5f5;
        }

        .hotkey-label {
            position: absolute;
            top: 5px;
            left: 8px;
            font-size: 0.7rem;
            color: #ccc;
            font-weight: bold;
        }

        .card-img-wrapper {
            flex: 1;
            width: 100%;
            display: flex;
            justify-content: center;
            overflow: hidden;
        }

        .card-img-wrapper img {
            height: 100%;
            width: 100%;
            object-fit: contain;
        }

        .input-stack {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        input[type="text"] {
            width: 100%;
            padding: 14px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1.1rem;
            outline: none;
        }

        input[type="text"]:focus {
            border-color: var(--primary);
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            font-size: 0.95rem;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-next-active {
            animation: pulse-green 2s infinite;
            background: var(--success) !important;
            color: white;
        }

        @keyframes pulse-green {
            0% {
                box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.7);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(40, 167, 69, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(40, 167, 69, 0);
            }
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .btn-outline {
            background: #fff;
            color: #444;
            border: 2px solid #ddd;
        }

        .feedback-area {
            min-height: 45px;
            margin-bottom: 1rem;
            text-align: center;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.3;
        }
    </style>
</head>

<body>
    <div id="app">
        <div v-if="currentCard && currentCard.prompt" style="display:contents;">
            <div class="content-section">
                <div class="prompt-area">
                    <div v-if="currentCard.prompt.image || currentCard.prompt.audio" class="media-placeholder">
                        <img v-if="currentCard.prompt.image" :src="currentCard.prompt.image" class="question-img">
                        <div v-else-if="currentCard.prompt.audio"
                            style="display: flex; flex-direction: column; align-items: center; width:100%;">
                            <button class="btn btn-outline" @click="handleAudioAutoplay">üîä Replay Sound</button>
                            <audio ref="audioPromptRef" :src="currentCard.prompt.audio" hidden></audio>
                        </div>
                    </div>
                    <h2 style="font-size: 1.2rem; margin: 0; color: #2d3436; text-align: center;">
                        {{ currentCard.prompt.text }}
                    </h2>
                </div>

                <div class="response-area">
                    <div class="feedback-area">
                        <span v-if="feedback.msg"
                            :style="{ color: feedback.type === 'success' ? 'var(--success)' : 'var(--error)' }">
                            {{ feedback.msg }}
                        </span>
                    </div>

                    <div v-if="currentCard.response?.choices" class="response-grid"
                        style="grid-template-columns: repeat(2, 1fr);">
                        <div v-for="(choice, i) in currentCard.response.choices" :key="i" class="card"
                            :class="{ correct: selectedIndex === i && choice.isCorrect, incorrect: selectedIndex === i && !choice.isCorrect }"
                            @click="selectCard(i, choice.isCorrect)">
                            <span class="hotkey-label">{{ i + 1 }}</span>
                            <div class="card-img-wrapper" v-if="choice.image"><img :src="choice.image"></div>
                            <div v-if="choice.text" style="margin-top:10px;"><b>{{ choice.text }}</b></div>
                        </div>
                    </div>

                    <div v-if="currentCard.response?.textAnswer !== undefined && !currentCard.response?.choices"
                        class="input-stack">
                        <input type="text" ref="textInputRef" v-model="textInput" placeholder="Type answer..."
                            @keyup.enter="checkText" @blur="checkText">
                        <button class="btn btn-primary" @click="checkText">Check</button>
                    </div>

                    <div v-if="currentCard.response?.audioAnswer" class="input-stack">
                        <div style="display:flex; gap:8px;">
                            <button v-if="!recordedUrl || isRecording" class="btn"
                                :class="isRecording ? 'btn-recording' : 'btn-outline'" @click="handleRecordClick"
                                style="flex:1">
                                {{ isRecording ? 'Stop' : 'üé§ Record' }}
                            </button>
                            <button v-else class="btn btn-outline" @click="toggleUserPlayback" style="flex:1">
                                {{ userAudioPlaying ? '‚è∏ Pause' : '‚ñ∂Ô∏è Replay' }}
                            </button>
                        </div>
                        <button class="btn btn-primary" :disabled="!recordedUrl || isRecording"
                            @click="toggleCorrectPlayback">
                            {{ correctAudioPlaying ? '‚è∏ Pause' : 'üîä Check' }}
                        </button>
                        <audio ref="userAudioRef" :src="recordedUrl" hidden></audio>
                        <audio ref="correctAudioRef" :src="currentCard.response.audioAnswer" hidden></audio>
                    </div>
                </div>

                <div class="footer-section">
                    <button class="btn btn-primary"
                        :class="{ 'btn-next-active': feedback.type === 'success' && nextCard }" @click="advanceToNext"
                        :disabled="!nextCard">
                        {{ nextCard ? '‚è≠Ô∏è Next' : 'Loading...' }}
                    </button>
                </div>
            </div>
        </div>
        <div v-else class="content-section" style="text-align:center; justify-content:center;">
            <p v-if="!errorMessage">Loading first question...</p>
            <p v-else style="color: var(--error)">{{ errorMessage }}</p>
        </div>
    </div>

    <script>
        const {createApp, ref, nextTick, onMounted} = Vue;
        createApp({
            setup() {
                const currentCard = ref(null);
                const nextCard = ref(null);
                const errorMessage = ref('');
                const drillId = new URLSearchParams(window.location.search).get('drill');

                const selectedIndex = ref(null);
                const textInput = ref('');
                const textInputRef = ref(null);
                const feedback = ref({msg: '', type: ''});
                const recordedUrl = ref(null);
                const isRecording = ref(false);
                const userAudioPlaying = ref(false);
                const correctAudioPlaying = ref(false);
                const userAudioRef = ref(null);
                const correctAudioRef = ref(null);
                const audioPromptRef = ref(null);
                let mediaRecorder = null;
                let chunks = [];

                const API_BASE = 'https://script.google.com/macros/s/AKfycby8ysnyr83c-vYmQ9QZtz6z1Til2BwlICE2O0nL8KrVjEYIwO3zZ4P0H2hHELeW6uSbQQ/exec';

                const fetchQuestion = async () => {
                    if (!drillId) return null;
                    try {
                        const response = await fetch(`${API_BASE}?drill=${drillId}`);
                        const json = await response.json();
                        return json.status === "ok" ? json.data : null;
                    } catch (e) {
                        console.error("Fetch error:", e);
                        return null;
                    }
                };

                const focusInput = async () => {
                    await nextTick();
                    if (textInputRef.value) textInputRef.value.focus();
                };

                const loadInitialData = async () => {
                    if (!drillId) {
                        errorMessage.value = "No Drill ID provided in URL (?drill=xxx)";
                        return;
                    }
                    const [first, second] = await Promise.all([fetchQuestion(), fetchQuestion()]);
                    if (first) {
                        currentCard.value = first;
                        nextCard.value = second;
                        handleAudioAutoplay();
                        focusInput();
                    } else {
                        errorMessage.value = "Failed to load data from API.";
                    }
                };

                const advanceToNext = async () => {
                    if (!nextCard.value) return;
                    resetUI();
                    currentCard.value = nextCard.value;
                    nextCard.value = null;
                    fetchQuestion().then(data => {nextCard.value = data;});
                    await nextTick();
                    handleAudioAutoplay();
                    focusInput();
                };

                const handleAudioAutoplay = async () => {
                    if (currentCard.value?.prompt?.audio) {
                        await nextTick();
                        if (audioPromptRef.value) {
                            audioPromptRef.value.load();
                            audioPromptRef.value.play().catch(() => console.log("Autoplay blocked"));
                        }
                    }
                };

                const selectCard = (idx, isCorrect) => {
                    selectedIndex.value = idx;
                    feedback.value = isCorrect ? {msg: '‚úÖ Correct!', type: 'success'} : {msg: '‚ùå Incorrect.', type: 'error'};
                };

                const checkText = () => {
                    if (!textInput.value.trim() && !feedback.value.msg) return;
                    const answer = currentCard.value?.response?.textAnswer || '';
                    const isCorrect = textInput.value.toLowerCase().trim() === answer.toLowerCase().trim();
                    if (isCorrect) {
                        feedback.value = {msg: '‚úÖ Correct!', type: 'success'};
                    } else {
                        feedback.value = {msg: `‚ùå Incorrect, answer is "${answer}"`, type: 'error'};
                    }
                };

                const resetUI = () => {
                    selectedIndex.value = null;
                    textInput.value = '';
                    feedback.value = {msg: '', type: ''};
                    recordedUrl.value = null;
                };

                // Hotkey listener
                onMounted(() => {
                    window.addEventListener('keydown', (e) => {
                        // Spacebar to replay audio
                        if (e.code === 'Space' && document.activeElement.tagName !== 'INPUT') {
                            e.preventDefault();
                            handleAudioAutoplay();
                        }

                        // Numbers 1-4 for Multiple Choice
                        if (currentCard.value?.response?.choices) {
                            const num = parseInt(e.key);
                            if (num >= 1 && num <= currentCard.value.response.choices.length) {
                                const idx = num - 1;
                                selectCard(idx, currentCard.value.response.choices[idx].isCorrect);
                            }
                        }

                        // Updated Enter Key Logic
                        if (e.key === 'Enter') {
                            const hasFeedback = feedback.value.msg !== '';
                            const isTextInput = currentCard.value?.response?.textAnswer !== undefined;

                            if (hasFeedback && nextCard.value) {
                                // If we already checked it (correct or incorrect), go to next
                                advanceToNext();
                            } else if (isTextInput) {
                                // If it's the first press, check the text
                                checkText();
                            }
                        }
                    });
                });

                // Audio recording methods (unchanged)
                const handleRecordClick = async () => { /* Logic as before */};
                const toggleUserPlayback = () => { /* Logic as before */};
                const toggleCorrectPlayback = () => { /* Logic as before */};

                loadInitialData();

                return {
                    currentCard, nextCard, errorMessage, selectedIndex, textInput, textInputRef, feedback,
                    recordedUrl, isRecording, userAudioPlaying, correctAudioPlaying,
                    userAudioRef, correctAudioRef, audioPromptRef,
                    advanceToNext, selectCard, checkText, handleRecordClick,
                    toggleUserPlayback, toggleCorrectPlayback, handleAudioAutoplay
                };
            }
        }).mount('#app');
    </script>
</body>

</html>
